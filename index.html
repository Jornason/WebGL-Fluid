<html>

<head>
<title>WebGL Fluid</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">


<script type="text/javascript" src="glMatrix-0.9.5.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="cubePool.js"></script>
<script type="text/javascript" src="cubeSky.js"></script>
<script type="text/javascript" src ="planeWater.js"></script>
<script type="text/javascript" src ="screenQuad.js"></script>

<script id="pool-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec3 aVertexNormal;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat4 uNmlMatrix;

    varying vec2 vTextureCoord;
    varying vec3 vVertexPosition;
   varying vec3 vVertexPositionMC;
    varying vec3 vVertexNormal;



    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vVertexPosition = aVertexPosition;//(uMVMatrix*vec4(aVertexPosition,1.0)).xyz;
        vVertexPositionMC = aVertexPosition;
        vTextureCoord = aTextureCoord;
       // vVertexNormal = aVertexNormal;
       vVertexNormal = (uNmlMatrix * vec4(aVertexNormal,0.0)).xyz;  
    }

</script>

<script id="pool-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec3 vVertexPosition;
    varying vec3 vVertexPositionMC;
    varying vec3 vVertexNormal;

    uniform sampler2D uSamplerTile;
   // uniform float waterHeight;


    float waterHeight = 0.0;
    vec3 lightPos = vec3(0.0,2.0,-2.0);
    vec3 lightDir = normalize(vec3(0.5,1.2,0.3));
   // vec3 lightDir = vec3(0.5,1.2,0.3);
    vec3 underwaterColor = vec3(0.4, 0.9, 1.0);
    float lightIntensity = 1.4;
    float poolHeight = 0.8;
    const float IOR_AIR = 1.0;
    const float IOR_WATER = 1.333;

    vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
        vec3 tMin = (cubeMin - origin) / ray;
        vec3 tMax = (cubeMax - origin) / ray;
        vec3 t1 = min(tMin, tMax);
        vec3 t2 = max(tMin, tMax);
        float tNear = max(max(t1.x, t1.y), t1.z);
        float tFar = min(min(t2.x, t2.y), t2.z);
        return vec2(tNear, tFar);
    }
    vec3 getWallColor(vec3 point) {
    float scale = 0.5;
    vec3 wallColor = vec3(1.0, 0.0, 0.0);
    vec3 normal;

    if (abs(point.x) > 0.999) {  //left,right wall
      wallColor = texture2D(uSamplerTile, point.zy * 0.5 + vec2(1.0, 0.5)).rgb;
   
      normal = vec3(-point.x, 0.0, 0.0);

    }
     else if (abs(point.z) > 0.999) {   //front,back wall
      wallColor = texture2D(uSamplerTile, point.xy * 0.5 + vec2(1.0, 0.5)).rgb;

      normal = vec3(0.0, 0.0, -point.z);

    } 
    else {   //bottm wall
      wallColor = texture2D(uSamplerTile, point.xz * 0.5 + 0.5).rgb;

      normal = vec3(0.0, 1.0, 0.0);
    }
    
    scale /= length(point); 
    //scale *= 1.0 - 0.9 / pow(length(point - sphereCenter) / sphereRadius, 4.0); 

    vec3 refractedLight = -refract(-lightDir, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
    float diffuse = max(0.0, dot(refractedLight, normal));
    //vec4 info = texture2D(water, point.xz * 0.5 + 0.5);
    //if (point.y < info.r) {
    //  vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);
    //  scale += diffuse * caustic.r * 2.0 * caustic.g;
    //} else {
      
      vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
      diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));
      
      scale += diffuse * 0.5;
    //}*/
    
    return wallColor * scale;
   //return wallColor;
  }
    void main(void) {
        vec3 lightDir = normalize(vVertexPosition-lightPos);
        float diffuseTerm = clamp(dot(normalize(lightDir), normalize(vVertexNormal) ), 0.0, 1.0);
        vec3 color = getWallColor(vVertexPosition);
        if(vVertexPositionMC.y < waterHeight){
            color *= underwaterColor;
        }

        vec2 tCube = intersectCube(lightPos, lightDir, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, poolHeight, 1.0));
        vec3 hitCube = lightPos - lightDir * tCube.y;
        //if(hitCube.y<0.99)
            //scolor *= vec3(0.5,0.5,0.5);
  
      //  gl_FragColor = vec4( abs(vVertexNormal),1.0);
      //gl_FragColor = vec4(vVertexPosition,1.0);
    //gl_FragColor = vec4(hitCube,1.0);

        //color *= lightIntensity*diffuseTerm;
      gl_FragColor = vec4(color, 1.0);
    }
</script>


<script id="sky-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
   // attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

   // varying vec2 vTextureCoord;
    varying vec3 vVertexPosition;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
       // vTextureCoord = aTextureCoord;
        vVertexPosition = aVertexPosition;
    }
</script>

<script id="sky-fs" type="x-shader/x-fragment">
    precision mediump float;

    uniform samplerCube uSamplerSky;
    //varying vec2 vTextureCoord;
    varying vec3 vVertexPosition;

    void main(void) {
         gl_FragColor = textureCube(uSamplerSky, vVertexPosition);
        //gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
    }
</script>

<script id="water-vs" type="x-shader/x-vertex">

    attribute vec3 aVertexPosition;
    //attribute vec2 aTextureCoord;
    attribute vec3 aVertexNormal;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat4 uNmlMatrix;  //for normal transformations
    uniform sampler2D uSamplerHeight;  //height texture: [position.y, velocity.y, normal.x, normal.z]

    varying vec3 vVertexPosition;
    //varying vec3 vVertexNormal;
    varying vec3 vVertexPositionWorld;

    void main(void) {

        vec4 data = texture2D(uSamplerHeight, aVertexPosition.xy * 0.5 + 0.5);
       

       // gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);//screen coord
        //vVertexNormal = (uNmlMatrix * vec4(aVertexNormal, 0.0)).xyz;
        //vVertexPositionWorld = (uMVMatrix * vec4(aVertexPosition.xzy, 1.0)).xyz;//world coord

        vVertexPosition = aVertexPosition.xzy;//gl_Position.xyz;

        vVertexPosition.y += data.x;   //retrieve height
        gl_Position = uPMatrix * uMVMatrix * vec4(vVertexPosition, 1.0);
    }

</script>

<script id="water-fs" type="x-shader/x-fragment">
   precision highp float;
   uniform sampler2D uSamplerTile;    //refracted ray shows pool tiles
    uniform samplerCube uSamplerSky;   //top water reflects skybox
    uniform sampler2D uSamplerHeight; 

    uniform vec3 uEyePosition;
    uniform int uProgNum;   //there is two water program, one is plane upper face, other is plane lower face

    varying vec3 vVertexPosition;
   // varying vec3 vVertexNormal;
    varying vec3 vVertexPositionWorld;

    float waterHeight = 0.0;
    vec3 lightDir = normalize(vec3(0.5,1.2,0.3));
    float poolHeight = 0.8;
    const float IOR_AIR = 1.0;
    const float IOR_WATER = 1.333;
    
    
    vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
        vec3 tMin = (cubeMin - origin) / ray;
        vec3 tMax = (cubeMax - origin) / ray;
        vec3 t1 = min(tMin, tMax);
        vec3 t2 = max(tMin, tMax);
        float tNear = max(max(t1.x, t1.y), t1.z);
        float tFar = min(min(t2.x, t2.y), t2.z);
        return vec2(tNear, tFar);
    }

  vec3 getWallColor(vec3 point) {
    float scale = 0.5;
    vec3 wallColor = vec3(1.0, 0.0, 0.0);
    vec3 normal;

    if (abs(point.x) > 0.999) {  //left,right wall
      wallColor = texture2D(uSamplerTile, point.zy * 0.5 + vec2(1.0, 0.5)).rgb;
    //  wallColor = texture2D(uSamplerTile, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;
      normal = vec3(-point.x, 0.0, 0.0);

    }
     else if (abs(point.z) > 0.999) {   //front,back wall
      wallColor = texture2D(uSamplerTile, point.xy * 0.5 + vec2(1.0, 0.5)).rgb;
     // wallColor = texture2D(uSamplerTile, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;
      normal = vec3(0.0, 0.0, -point.z);

    } 
    else {   //bottm wall
      wallColor = texture2D(uSamplerTile, point.xz * 0.5 + 0.5).rgb;
      normal = vec3(0.0, 1.0, 0.0);
    }
    
    scale /= length(point); 
    //scale *= 1.0 - 0.9 / pow(length(point - sphereCenter) / sphereRadius, 4.0); 

    vec3 refractedLight = -refract(-lightDir, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
    float diffuse = max(0.0, dot(refractedLight, normal));
    //vec4 info = texture2D(water, point.xz * 0.5 + 0.5);
    //if (point.y < info.r) {
    //  vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);
    //  scale += diffuse * caustic.r * 2.0 * caustic.g;
    //} else {
      
    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));
    
    scale += diffuse * 0.5;
    //}*/
    
    return wallColor * scale;
   //return wallColor;
  }

    vec3 getRayColor(vec3 origin, vec3 ray, vec3 waterColor) {
        vec3 color;
        //float q = intersectSphere(origin, ray, sphereCenter, sphereRadius);
        //if (q < 1.0e6) {
          //color = getSphereColor(origin + ray * q);
        //} else 
        if (ray.y < 0.0) {
          vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, poolHeight, 1.0));
          color = getWallColor(origin + ray * t.y);
        } else {
          vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, poolHeight, 1.0));
          vec3 hit = origin + ray * t.y;
          if (hit.y < 1.0 / 2.0) {
            color = getWallColor(hit);
          } else {
            color = textureCube(uSamplerSky, ray).rgb;
            color += vec3(pow(max(0.0, dot(lightDir, ray)), 5000.0)) * vec3(10.0, 8.0, 6.0);
          }
        }
        if (ray.y < 0.0) color *= waterColor;
        return color;
      }

    void main(void) {

        //vec3 normal = normalize(vVertexNormal);
        vec3 normal = vec3(0,1,0);
        vec3 eyeDir = normalize(vVertexPosition - uEyePosition);
        
        vec3 underwaterColor = vec3(0.4, 0.9, 1.0);
        vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);

        if(uProgNum == 0){   //above water
         vec3 reflectDir = reflect(eyeDir,normal);
          vec3 refractDir = refract(eyeDir,normal, IOR_AIR / IOR_WATER); 
          float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -eyeDir), 3.0)); 
          vec3 refraColor = getRayColor(vVertexPosition, refractDir, underwaterColor);
          vec3 refleColor = getRayColor(vVertexPosition, reflectDir, underwaterColor);
          gl_FragColor = vec4(mix(refleColor, refraColor, fresnel), 1.0);

        }else if(uProgNum == 1){  //below water

          normal = -normal;
          vec3 reflectDir = reflect(eyeDir,normal);
          vec3 refractDir = refract(eyeDir,normal, IOR_WATER/IOR_AIR ); 
          float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -eyeDir), 3.0)); 
          vec3 refraColor = getRayColor(vVertexPosition, refractDir, abovewaterColor);
          vec3 refleColor = getRayColor(vVertexPosition, reflectDir, abovewaterColor);
          gl_FragColor = vec4(mix(refleColor, refraColor, (1.0 - fresnel) * length(refractDir)), 1.0);   

        }


//gl_FragColor = vec4(vVertexPosition,1.0);
          //gl_FragColor = vec4(refraColor, 1.0);

       //vec3 heightcolor = texture2D(uSamplerHeight, vVertexPosition.xy).rgb;
    
        //gl_FragColor = texture2D(uSamplerHeight, vVertexPosition.xy);
       //gl_FragColor = vec4(heightcolor,1.0);
    }

</script>

<script id="interact-vs" type="x-shader/x-vertex">

 attribute vec3 aVertexPosition;  // [-1, 1]

//  uniform mat4 uMVMatrix;
 // uniform mat4 uPMatrix;

 varying vec2 vCoord;

    void main() {
        gl_Position = vec4(aVertexPosition.xyz, 1.0);
        vCoord = aVertexPosition.xy * 0.5 + 0.5;   //screen coords to texture coords
     }
</script>

<script id="interact-ripple-fs" type="x-shader/x-fragment">
  precision highp float;

    const float PI = 3.141592653589793;
    uniform sampler2D uSamplerFloat;
    uniform vec2 uCenter;    //[-1,1]

   // uniform float radius;
   // uniform float strength;
 
   float radius = 0.03;   //0.03
   float strength = 0.001;   //0.01

    varying vec2 vCoord;

    void main() {
      vec4 data = texture2D(uSamplerFloat, vCoord);
      vec2 dragCoord = uCenter * 0.5 + 0.5;     //[0,1]
      float dist = length(dragCoord - vCoord);    //[0,1]
      float drag = max(0.0, 100.0 - dist/ radius);    
    //  drag = 1.0 - cos(drag * PI);
     //drag = cos(drag * PI);
      data.x += drag * strength;   //add height
      //data.x+= dist/1000.0;


//data.x += uCenter.x /10.0;
//data.x -= uCenter.y /10.0;
      gl_FragColor = data;

      //gl_FragColor = data+ vec4(0.01, 0.01, 0.01, 0.01);
    }
</script>

 <script id="interact-normal-fs" type="x-shader/x-fragment">
   /* precision mediump float;
    uniform sampler2D texture;
    uniform vec2 delta;
    varying vec2 coord;*/
    void main() {
  /*
      vec4 data = texture2D(texture, coord);
    
      vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);
      vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);
      info.ba = normalize(cross(dy, dx)).xz;
      
      gl_FragColor = data;*/
    }
</script>

</head> 

<body onload="webGLStart();">

<table>
      <tr>
          <td>
              <canvas id="the-canvas" width="1080" height="720">  WebGL unavailable. </canvas>

          </td>

          <td align="left" valign="top" style="position:absolute;left:1080px;padding:20px;">
              <h1><strong>WebGL Interactive Water</strong></h1> <br>
              <a href = "http://www.bingludu.com" target = "_blank"><strong>Binglu's Website</strong></a>  <br>
              <a href = "http://www.maxinjie.com/ " target = "_blank"><strong>Xinjie's Website</strong></a> <br>
              <a href = "https://github.com/dblsai/WebGL-Fluid" target = "_blank"><strong>View Source</strong></a> <br>
              <br><strong>Interaction: </strong><br></h3>
              <ul>
              <li>Right Mouse Button - rotate</li>
              <li>Left Mouse Button - interact </li>
              <li>Middle Mouse Wheel - zoom </li>
   
              </ul>
              <br><strong>Features:</strong> <br>
              <ul>
              <li>Reflection </li>
              <li>Refraction </li>
              <li>Soft Shadow </li>
              </ul>
        
      
          <div>fps: <span id="fps"></span></div>
          </td>
      </tr>
</table>

 
</body>

</html>
