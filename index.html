<html>

<head>
<title>WebGL Fluid</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">


<script type="text/javascript" src="glMatrix-0.9.5.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src ="primitives.js"></script>

<script id="pool-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec3 aVertexNormal;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat4 uNmlMatrix;
    varying vec2 vTextureCoord;
    varying vec3 vVertexPosition;
    varying vec3 vVertexPositionMC;
    varying vec3 vVertexNormal;
    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vVertexPosition = aVertexPosition;//(uMVMatrix*vec4(aVertexPosition,1.0)).xyz;
        vVertexPositionMC = aVertexPosition;
        vTextureCoord = aTextureCoord;
       // vVertexNormal = aVertexNormal;
       vVertexNormal = (uNmlMatrix * vec4(aVertexNormal,0.0)).xyz;  
    }
</script>

<script id="pool-fs" type="x-shader/x-fragment">
    precision mediump float;
    varying vec2 vTextureCoord;
    varying vec3 vVertexPosition;
    varying vec3 vVertexPositionMC;
    varying vec3 vVertexNormal;
    uniform sampler2D uSamplerTile;
    uniform sampler2D uSamplerCaustic;
     uniform sampler2D uSamplerHeight; 
   // uniform float waterHeight;
    float waterHeight = 0.0;
    vec3 lightPos = vec3(0.0,2.0,-2.0);
    vec3 lightDir = normalize(vec3(0.5,1.2,0.3));
   // vec3 lightDir = vec3(0.5,1.2,0.3);
    vec3 underwaterColor = vec3(0.4, 0.9, 1.0);
    float lightIntensity = 1.4;
    float poolHeight = 0.8;
    const float IOR_AIR = 1.0;
    const float IOR_WATER = 1.333;
    vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
        vec3 tMin = (cubeMin - origin) / ray;
        vec3 tMax = (cubeMax - origin) / ray;
        vec3 t1 = min(tMin, tMax);
        vec3 t2 = max(tMin, tMax);
        float tNear = max(max(t1.x, t1.y), t1.z);
        float tFar = min(min(t2.x, t2.y), t2.z);
        return vec2(tNear, tFar);
    }
    vec3 getWallColor(vec3 point) {
    float scale = 0.5;
    vec3 wallColor;
    vec3 normal;
    if (abs(point.x) > 0.999) {  //left,right wall
      wallColor = texture2D(uSamplerTile, point.zy * 0.5 + vec2(1.0, 0.5)).rgb;
   
      normal = vec3(-point.x, 0.0, 0.0);
    }
     else if (abs(point.z) > 0.999) {   //front,back wall
      wallColor = texture2D(uSamplerTile, point.xy * 0.5 + vec2(1.0, 0.5)).rgb;
      normal = vec3(0.0, 0.0, -point.z);
    } 
    else {   //bottm wall
      wallColor = texture2D(uSamplerTile, point.xz * 0.5 + 0.5).rgb;
      normal = vec3(0.0, 1.0, 0.0);
    }
    
    scale /= length(point); 
    //scale *= 1.0 - 0.9 / pow(length(point - sphereCenter) / sphereRadius, 4.0); 
    vec3 refractedLight = -refract(-lightDir, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
    float diffuse = max(0.0, dot(refractedLight, normal));
    vec4 info = texture2D(uSamplerHeight, point.xz * 0.5 + 0.5);
    vec4 caustic;
    //if (point.y < info.r) {
      caustic = texture2D(uSamplerCaustic, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);
      scale += diffuse * caustic.r * 2.0 * caustic.g;
   // } else {
     
      vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
      diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));
      
      scale += diffuse * 0.5;
    //}
    
    //return wallColor * scale;
    return vec3(caustic.r);
   //return wallColor;
  }
    void main(void) {
        vec3 lightDir = normalize(vVertexPosition-lightPos);
        float diffuseTerm = clamp(dot(normalize(lightDir), normalize(vVertexNormal) ), 0.0, 1.0);
        vec3 color = getWallColor(vVertexPosition);
        if(vVertexPositionMC.y < waterHeight){
            color *= underwaterColor;
        }
        vec2 tCube = intersectCube(lightPos, lightDir, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, poolHeight, 1.0));
        vec3 hitCube = lightPos - lightDir * tCube.y;
        //if(hitCube.y<0.99)
            //scolor *= vec3(0.5,0.5,0.5);
  
      //  gl_FragColor = vec4( abs(vVertexNormal),1.0);
      //gl_FragColor = vec4(vVertexPosition,1.0);
    //gl_FragColor = vec4(hitCube,1.0);
        //color *= lightIntensity*diffuseTerm;

       // color = texture2D(uSamplerCaustic,vVertexPosition.xz * 0.5 + 0.5).rgb;
      gl_FragColor = vec4(color, 1.0);
    }
</script>


<script id="sky-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
   // attribute vec2 aTextureCoord;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
   // varying vec2 vTextureCoord;
    varying vec3 vVertexPosition;
    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
       // vTextureCoord = aTextureCoord;
        vVertexPosition = aVertexPosition;
    }
</script>

<script id="sky-fs" type="x-shader/x-fragment">
    precision mediump float;
    uniform samplerCube uSamplerSky;
    //varying vec2 vTextureCoord;
    varying vec3 vVertexPosition;
    void main(void) {
         gl_FragColor = textureCube(uSamplerSky, vVertexPosition);
        //gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
    }
</script>

<script id="obj-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
   // attribute vec2 aTextureCoord;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform vec3 uCenter;
   // uniform vec3 uRadius;
   // varying vec2 vTextureCoord;
    varying vec3 vVertexPosition;
    varying vec3 vVertexNormal;
    void main(void) {
        vVertexPosition = uCenter + aVertexPosition;
        // vVertexPosition = aVertexPosition;
        gl_Position = uPMatrix * uMVMatrix * vec4(vVertexPosition, 1.0);
       // vTextureCoord = aTextureCoord;
       
        vVertexNormal = aVertexNormal;
    }
</script>

<script id="obj-fs" type="x-shader/x-fragment">
    precision mediump float;
    //uniform sampler2D uSamplerSphere;
    //varying vec2 vTextureCoord;
   // uniform vec3 uDiffuseColor;
    varying vec3 vVertexPosition;
    varying vec3 vVertexNormal;
    vec3 lightPos = vec3(0.0,6.0,0.0);
    vec3 underwaterColor = vec3(0.4, 0.9, 1.0);

    void main(void) {
        //gl_FragColor = texture2D(uSamplerSphere, vTextureCoord);
        vec3 lightDir = normalize(vVertexPosition-lightPos);
        float diffuseTerm = clamp(dot(-lightDir, vVertexNormal), 0.35, 1.0);
        vec3 diffuseColor = vec3(1.0, 1.0, 1.0);
        vec3 color = diffuseColor*diffuseTerm;
        if(vVertexPosition.y < 0.0){
          color *= underwaterColor;
        }
         gl_FragColor = vec4(color,1.0);
    }
</script>

<script id="water-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    //attribute vec2 aTextureCoord;
    attribute vec3 aVertexNormal;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat4 uNmlMatrix;  //for normal transformations
    uniform sampler2D uSamplerHeight;  //height texture: [position.y, normal.x, normal.z, velocity.y]
    varying vec3 vVertexPosition;
    //varying vec3 vVertexNormal;
    varying vec3 vVertexPositionWorld;
    void main(void) {
        vec4 data = texture2D(uSamplerHeight, aVertexPosition.xy * 0.5 + 0.5);
       
       // gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);//screen coord
        //vVertexNormal = (uNmlMatrix * vec4(aVertexNormal, 0.0)).xyz;
        //vVertexPositionWorld = (uMVMatrix * vec4(aVertexPosition.xzy, 1.0)).xyz;//world coord
        vVertexPosition = aVertexPosition.xzy;//gl_Position.xyz;

        vVertexPosition.y += data.x;   //retrieve height


        vVertexPosition.y += data.r;   //retrieve height

        gl_Position = uPMatrix * uMVMatrix * vec4(vVertexPosition, 1.0);
    }
</script>

<script id="water-fs" type="x-shader/x-fragment">
   precision highp float;

    uniform sampler2D uSamplerTile;    //refracted ray shows pool tiles
    uniform samplerCube uSamplerSky;   //top water reflects skybox
    uniform sampler2D uSamplerHeight; 
    uniform sampler2D uSamplerCaustic;
    uniform vec3 uEyePosition;
    uniform int uProgNum;   //there is two water program, one is plane upper face, other is plane lower face
    uniform float uSphereRadius;
    uniform vec3 uSphereCenter;

    varying vec3 vVertexPosition;
   // varying vec3 vVertexNormal;
    varying vec3 vVertexPositionWorld;

    float waterHeight = 0.0;
    vec3 lightDir = normalize(vec3(0.5,1.2,0.3));
    float poolHeight = 0.8;
    const float IOR_AIR = 1.0;
    const float IOR_WATER = 1.333;

    float intersectSphere(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
      vec3 toSphere = origin - sphereCenter;
      float a = dot(ray, ray);
      float b = 2.0 * dot(toSphere, ray);
      float c = dot(toSphere, toSphere) - sphereRadius * sphereRadius;
      float discriminant = b*b - 4.0*a*c;
      if (discriminant > 0.0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if (t > 0.0) return t;
      }
      return 1.0e6;
  }
    
    
    vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
        vec3 tMin = (cubeMin - origin) / ray;
        vec3 tMax = (cubeMax - origin) / ray;
        vec3 t1 = min(tMin, tMax);
        vec3 t2 = max(tMin, tMax);
        float tNear = max(max(t1.x, t1.y), t1.z);
        float tFar = min(min(t2.x, t2.y), t2.z);
        return vec2(tNear, tFar);
    }


    vec3 getSphereColor(vec3 point,  vec3 sphereCenter, float sphereRadius) {
      vec3 color = vec3(0.5);

      color *= 1.0 - 0.9 / pow((1.0 + sphereRadius - abs(point.x)) / sphereRadius, 3.0);
      color *= 1.0 - 0.9 / pow((1.0 + sphereRadius - abs(point.z)) / sphereRadius, 3.0);
      color *= 1.0 - 0.9 / pow((point.y + 1.0 + sphereRadius) / sphereRadius, 3.0);

      vec3 sphereNormal = (point - sphereCenter) / sphereRadius;
      vec3 refractedLight = refract(-lightDir, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
      float diffuse = max(0.0, dot(-refractedLight, sphereNormal)) * 0.5;
      vec4 info = texture2D(uSamplerHeight, point.xz * 0.5 + 0.5);
      if (point.y < info.r) {
        //vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);
       // diffuse *= caustic.r * 4.0;
      }
      color += diffuse;
      return color;
  }


  vec3 getWallColor(vec3 point) {
    float scale = 0.5;
    vec3 wallColor = vec3(1.0, 0.0, 0.0);
    vec3 normal;
    if (abs(point.x) > 0.999) {  //left,right wall
      wallColor = texture2D(uSamplerTile, point.zy * 0.5 + vec2(1.0, 0.5)).rgb;
    //  wallColor = texture2D(uSamplerTile, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;
      normal = vec3(-point.x, 0.0, 0.0);
    }
     else if (abs(point.z) > 0.999) {   //front,back wall
      wallColor = texture2D(uSamplerTile, point.xy * 0.5 + vec2(1.0, 0.5)).rgb;
     // wallColor = texture2D(uSamplerTile, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;
      normal = vec3(0.0, 0.0, -point.z);
    } 
    else {   //bottm wall
      wallColor = texture2D(uSamplerTile, point.xz * 0.5 + 0.5).rgb;
      normal = vec3(0.0, 1.0, 0.0);
    }
    
    scale /= length(point); 
    //scale *= 1.0 - 0.9 / pow(length(point - sphereCenter) / sphereRadius, 4.0); 
    vec3 refractedLight = -refract(-lightDir, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
    float diffuse = max(0.0, dot(refractedLight, normal));
    //vec4 info = texture2D(water, point.xz * 0.5 + 0.5);
    //if (point.y < info.r) {
    //  vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);
    //  scale += diffuse * caustic.r * 2.0 * caustic.g;
    //} else {
      
    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));
    
    scale += diffuse * 0.5;
    //}*/
    
    return wallColor * scale;
   //return wallColor;
  }
    vec3 getRayColor(vec3 origin, vec3 ray, vec3 waterColor) {
        vec3 color;
        float q = intersectSphere(origin, ray, uSphereCenter, uSphereRadius);
        if (q < 1.0e6) {
          color = getSphereColor(origin + ray * q,  uSphereCenter, uSphereRadius);
        } else if (ray.y < 0.0) {
          vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, poolHeight, 1.0));
          color = getWallColor(origin + ray * t.y);
        } else {
          vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, poolHeight, 1.0));
          vec3 hit = origin + ray * t.y;
          if (hit.y < 1.0 / 2.0) {
            color = getWallColor(hit);
          } else {
            color = textureCube(uSamplerSky, ray).rgb;
            color += vec3(pow(max(0.0, dot(lightDir, ray)), 5000.0)) * vec3(10.0, 8.0, 6.0);
          }
        }
        if (ray.y < 0.0) color *= waterColor;
        return color;
      }
    void main(void) {
        //vec3 normal = normalize(vVertexNormal);
        //vec3 normal = vec3(0,1,0);
        vec2 coord = vVertexPosition.xz * 0.5 + 0.5;
        vec4 data = texture2D(uSamplerHeight, coord);
        vec3 normal = vec3(data.g, sqrt(1.0 - dot(data.gb, data.gb)), data.b);
        vec3 eyeDir = normalize(vVertexPosition - uEyePosition);
        
        vec3 underwaterColor = vec3(0.4, 0.9, 1.0);
        vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);
        if(uProgNum == 0){   //above water
         vec3 reflectDir = reflect(eyeDir,normal);
          vec3 refractDir = refract(eyeDir,normal, IOR_AIR / IOR_WATER); 
          float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -eyeDir), 3.0)); 
          vec3 refraColor = getRayColor(vVertexPosition, refractDir, underwaterColor);
          vec3 refleColor = getRayColor(vVertexPosition, reflectDir, underwaterColor);
          gl_FragColor = vec4(mix(refleColor, refraColor, fresnel), 1.0);
        }else if(uProgNum == 1){  //below water
          normal = -normal;
          vec3 reflectDir = reflect(eyeDir,normal);
          vec3 refractDir = refract(eyeDir,normal, IOR_WATER/IOR_AIR ); 
          float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -eyeDir), 3.0)); 
          vec3 refraColor = getRayColor(vVertexPosition, refractDir, abovewaterColor);
          vec3 refleColor = getRayColor(vVertexPosition, reflectDir, abovewaterColor);
          gl_FragColor = vec4(mix(refleColor, refraColor, (1.0 - fresnel) * length(refractDir)), 1.0);   
        }
//gl_FragColor = vec4(vVertexPosition,1.0);
          //gl_FragColor = vec4(refraColor, 1.0);
       //vec3 heightcolor = texture2D(uSamplerHeight, vVertexPosition.xy).rgb;
    
        //gl_FragColor = texture2D(uSamplerHeight, vVertexPosition.xy);
       //gl_FragColor = vec4(heightcolor,1.0);
    }
</script>

<script id="caustic-vs" type="x-shader/x-vertex">
    //uniform sampler2D uSamplerHeight;
     attribute vec3 aVertexPosition;

     varying vec3 oldPos;
     varying vec3 newPos;
     varying vec3 ray;
     float poolHeight = 0.8;
     vec3 lightDir = normalize(vec3(0.5,1.2,0.3));
     const float IOR_AIR = 1.0;
     const float IOR_WATER = 1.333;
     
    //  vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
    //     vec3 tMin = (cubeMin - origin) / ray;
    //     vec3 tMax = (cubeMax - origin) / ray;
    //     vec3 t1 = min(tMin, tMax);
    //     vec3 t2 = max(tMin, tMax);
    //     float tNear = max(max(t1.x, t1.y), t1.z);
    //     float tFar = min(min(t2.x, t2.y), t2.z);
    //     return vec2(tNear, tFar);
    // }
     // vec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {
     //    vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
     //    origin += ray * tcube.y;
     //    float tplane = (-origin.y - 1.0) / refractedLight.y;
     //    return origin + refractedLight * tplane;
     // }
  
     void main() {
       // vec4 info = texture2D(uSamplerHeight, aVertexPosition.xy * 0.5 + 0.5);
       // info.gb *= 0.5;  //normal
       // vec3 normal = vec3(info.g, sqrt(1.0 - dot(info.gb, info.gb)), info.b);
       
       // vec3 refractedLight = refract(-lightDir, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
       // ray = refract(-lightDir, normal, IOR_AIR / IOR_WATER);
       // oldPos = project(aVertexPosition.xzy, refractedLight, refractedLight);
       // newPos = project(aVertexPosition.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);
      
       // gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);
        gl_Position = vec4(aVertexPosition.xyz, 1.0);
     
     }
   
</script>

<script id="caustic-fs" type="x-shader/x-fragment">
    precision highp float;
  //  #extension GL_OES_standard_derivatives : enable

     varying vec3 oldPos;
     varying vec3 newPos;
     varying vec3 ray;
     vec3 lightDir = normalize(vec3(0.5,1.2,0.3));
     const float IOR_AIR = 1.0;
     const float IOR_WATER = 1.333;
     float poolHeight = 0.8;

     //uniform int OES_standard_derivatives;
    // vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
    //     vec3 tMin = (cubeMin - origin) / ray;
    //     vec3 tMax = (cubeMax - origin) / ray;
    //     vec3 t1 = min(tMin, tMax);
    //     vec3 t2 = max(tMin, tMax);
    //     float tNear = max(max(t1.x, t1.y), t1.z);
    //     float tFar = min(min(t2.x, t2.y), t2.z);
    //     return vec2(tNear, tFar);
    // }
     void main() {
       
       //if(OES_standard_derivatives > 0){
          // float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));
          // float newArea = length(dFdx(newPos)) * length(dFdy(newPos)); 
          // gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);
       //}else{
          //gl_FragColor = vec4(0.2, 0.2, 0.0, 0.0);
       //}
     
     //  vec3 refractedLight = refract(-lightDir, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
      
       //vec3 dir = (sphereCenter - newPos) / sphereRadius;
       //vec3 area = cross(dir, refractedLight);
       //float shadow = dot(area, area);
       //float dist = dot(dir, -refractedLight);
       //shadow = 1.0 + (shadow - 1.0) / (0.05 + dist * 0.025);
      //shadow = clamp(1.0 / (1.0 + exp(-shadow)), 0.0, 1.0);
       //shadow = mix(1.0, shadow, clamp(dist * 2.0, 0.0, 1.0));
       //gl_FragColor.g = shadow;
      
      // vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
       //gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));
       gl_FragColor = vec4(0.5, 0.8, 1.0, 1.0);
     }
    
</script>


<script id="interact-vs" type="x-shader/x-vertex">
 attribute vec3 aVertexPosition;  // [-1, 1]
//  uniform mat4 uMVMatrix;
 // uniform mat4 uPMatrix;
 varying vec2 vCoord;
    void main() {
        gl_Position = vec4(aVertexPosition.xyz, 1.0);
        vCoord = aVertexPosition.xy * 0.5 + 0.5;   //screen coords to texture coords
     }
</script>

<script id="interact-height-fs" type="x-shader/x-fragment">
  precision highp float;
    const float PI = 3.141592653589793;
    uniform sampler2D uSamplerFloat;
    uniform vec2 uCenter;    //[-1,1]
   // uniform float radius;
   // uniform float strength;
 
   float radius = 0.03;   //0.03
   float strength = 0.01;   //0.01
    varying vec2 vCoord;
    float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
    void main() {
      vec4 data = texture2D(uSamplerFloat, vCoord);
      vec2 dragCoord = uCenter * 0.5 + 0.5;     //[0,1]
     float dist = length(dragCoord - vCoord);    //[0,1]
      //data.x += dist;
      float drag = max(0.0, 1.0 - dist/ radius);  
     drag = 0.5 - cos(drag * PI)*0.5;
     //drag = cos(drag * PI);
      //data.x += drag * strength;   //add height
      //data.x+= dist/1000.0;
// drag = clamp(rand(vCoord), 0.0, 0.2);
// drag = 0.5 - cos(drag * PI)*0.5;
     data.x += drag* strength;
//data.x += uCenter.x /10.0;
//data.x -= uCenter.y /10.0;
      gl_FragColor = data;

    }
</script>

 <script id="interact-normal-fs" type="x-shader/x-fragment">
    precision mediump float;
    uniform sampler2D uSamplerFloat;
    uniform vec2 uDelta;
    varying vec2 vCoord;
    void main() {   
      vec4 data = texture2D(uSamplerFloat, vCoord);
      vec3 dx = vec3(uDelta.x, texture2D(uSamplerFloat, vec2(vCoord.x + uDelta.x, vCoord.y)).r - data.r, 0.0);
      vec3 dy = vec3(0.0, texture2D(uSamplerFloat, vec2(vCoord.x, vCoord.y + uDelta.y)).r - data.r, uDelta.y);
      data.gb = normalize(cross(dy, dx)).xz;
      gl_FragColor = data;
    }
</script>

<script id="interact-simulate-fs" type="x-shader/x-fragment">
    precision mediump float;
    uniform sampler2D uSamplereFloat;
    uniform vec2 uDelta;
    varying vec2 vCoord;
    void main() {

      vec4 data = texture2D(uSamplereFloat, vCoord);
      vec2 dx = vec2(uDelta.x, 0.0);
      vec2 dy = vec2(0.0, uDelta.y);
      float average = 0.25 * ( texture2D(uSamplereFloat, vCoord - dx).r + texture2D(uSamplereFloat, vCoord - dy).r +
        texture2D(uSamplereFloat, vCoord + dx).r + texture2D(uSamplereFloat, vCoord  + dy).r);
      data.a += (average - data.r) * 2.0; 
      data.a *= 0.993;
      data.r += data.a;   //update height
      gl_FragColor = data;
    }
</script>

<script id="interact-sphere-fs" type="x-shader/x-fragment">
    precision mediump float;

    uniform sampler2D uSamplerFloat;
    uniform vec3 uOldCenter;
    uniform vec3 uNewCenter;
    uniform float uRadius;

    varying vec2 vCoord;
    
    float volumeInSphere(vec3 center) {
      vec3 toCenter = vec3(vCoord.x * 2.0 - 1.0, 0.0, vCoord.y * 2.0 - 1.0) - center;
      float t = length(toCenter) / uRadius;
      float dy = exp(-pow(t * 1.5, 6.0));
      float ymin = min(0.0, center.y - dy);
      float ymax = min(max(0.0, center.y + dy), ymin + 2.0 * dy);
      return (ymax - ymin) * 0.1;
    }
    void main() {

      vec4 data = texture2D(uSamplerFloat, vCoord);
      data.r += volumeInSphere(uOldCenter);
      data.r -= volumeInSphere(uNewCenter);
      //data.r += 0.1;
      gl_FragColor = data;
    }
</script>



</head> 

<body onload="webGLStart();">

<table>
      <tr>
          <td>
              <canvas id="the-canvas" width="1080" height="720" style="cursor:hand;">  WebGL unavailable. </canvas>

          </td>

          <td align="left" valign="top" style="position:absolute;left:1080px;padding:20px;">
              <h1><strong>WebGL Interactive Water</strong></h1> <br>
              <a href = "http://www.bingludu.com" target = "_blank"><strong>Binglu's Website</strong></a>  <br>
              <a href = "http://www.maxinjie.com/ " target = "_blank"><strong>Xinjie's Website</strong></a> <br>
              <a href = "https://github.com/dblsai/WebGL-Fluid" target = "_blank"><strong>View Source</strong></a> <br>
              <br><strong>Interaction: </strong><br></h3>
              <ul>
              <li>Right Mouse Button - rotate</li>
              <li>Left Mouse Button - interact </li>
              <li>Middle Mouse Wheel - zoom </li>
   
              </ul>
              <br><strong>Features:</strong> <br>
              <ul>
              <li>Reflection </li>
              <li>Refraction </li>
              <li>Soft Shadow </li>
              </ul>
        
      
          <div>fps: <span id="fps"></span></div>
          </td>
      </tr>
</table>

 
</body>

</html>
